#!/usr/bin/env python3
from fastapi import FastAPI, HTTPException, Request, Body
from fastapi.responses import HTMLResponse, JSONResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
import pandas as pd
from typing import List, Dict, Optional
import uvicorn
import time
import logging
from datetime import datetime
import asyncio
from concurrent.futures import ThreadPoolExecutor
import json
import os

from data.loader import data_loader
from utils.logging import setup_logging

setup_logging(logging.INFO)
logger = logging.getLogger(__name__)
app = FastAPI(
    title="Kavak Trade-Up Engine",
    description="Modern, fast, and intelligent trade-up offer generation",
    version="2.0.0"
)

app.mount("/static", StaticFiles(directory="app/static"), name="static")
from fastapi.templating import Jinja2Templates
templates = Jinja2Templates(directory="app/templates")

import multiprocessing
cpu_count = multiprocessing.cpu_count()
executor = ThreadPoolExecutor(max_workers=cpu_count)
logger.info(f"üñ•Ô∏è Using {cpu_count} worker threads on {cpu_count}-core system")
customers_df = pd.DataFrame()
inventory_df = pd.DataFrame()

import functools
import hashlib
from datetime import datetime, timedelta

class OfferCache:
    def __init__(self, ttl_minutes=15):
        self.cache = {}
        self.ttl = timedelta(minutes=ttl_minutes)
    
    def __len__(self):
        """Return number of cached entries"""
        return len(self.cache)
    
    def get_key(self, customer_id: str, fees: dict = None):
        """Generate cache key from customer ID and fees"""
        fees_str = json.dumps(fees or {}, sort_keys=True)
        return hashlib.md5(f"{customer_id}:{fees_str}".encode()).hexdigest()
    
    def get(self, key: str):
        """Get from cache if not expired"""
        # DISABLED - Always return None to force recalculation
        return None
    
    def set(self, key: str, data: dict):
        """Set in cache with expiration"""
        self.cache[key] = {
            'data': data,
            'expires': datetime.now() + self.ttl
        }

offer_cache = OfferCache()

class OfferRequest(BaseModel):
    customer_id: str
    max_offers: int = Field(default=10, le=50)
    use_smart_engine: bool = True

class BulkOfferRequest(BaseModel):
    customer_ids: List[str]
    max_offers_per_customer: int = Field(default=5, le=20)

class SearchRequest(BaseModel):
    query: str
    limit: int = Field(default=20, le=100)
    filters: Optional[Dict] = None

# --- Startup Event ---
@app.on_event("startup")
async def startup_event():
    """Load data on startup"""
    global customers_df, inventory_df
    
    logger.info("üöÄ Starting Modern Trade-Up Engine...")
    
    try:
        # Load customer data
        customers_df = data_loader.load_customers()
        
        # Load inventory data  
        inventory_df = data_loader.load_inventory()
        
        logger.info(f"‚úÖ Loaded {len(customers_df)} customers and {len(inventory_df)} inventory items")
    except Exception as e:
        logger.error(f"Failed to load data: {e}")
        # Use empty dataframes as fallback
        customers_df = pd.DataFrame()
        inventory_df = pd.DataFrame()
    
    logger.info("üéØ Simple engine initialized and ready!")

# --- Helper Functions ---
def get_data_context():
    """Get context about data sources for trust indicators"""
    is_mock = len(customers_df) < 10 or len(inventory_df) < 30
    
    return {
        "data_source": "mock" if is_mock else "production",
        "customer_count": len(customers_df),
        "inventory_count": len(inventory_df),
        "customer_source": "customer_data.csv" if is_mock else "Redshift + CSV",
        "inventory_source": "inventory_data.csv" if is_mock else "Redshift",
        "last_update": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "last_sync": "Just now",
        "cache_status": f"{len(offer_cache)} offers cached"
    }

# --- Page Routes ---
@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Modern dashboard with real-time metrics"""
    metrics = {
        "total_customers": len(customers_df),
        "total_inventory": len(inventory_df),
        "avg_npv": 7500,  # Would calculate from recent offers
        "conversion_rate": 68
    }
    
    context = {
        "request": request,
        "metrics": metrics,
        "active_page": "dashboard",
        **get_data_context()
    }
    
    return templates.TemplateResponse(
        "modern_dashboard.html",
        context
    )

@app.get("/customers", response_class=HTMLResponse)
async def customers_page(request: Request):
    """Customer search and management page"""
    context = {
        "request": request,
        "active_page": "customers",
        **get_data_context()
    }
    return templates.TemplateResponse(
        "modern_customers.html",
        context
    )

@app.get("/customer/{customer_id}", response_class=HTMLResponse)
async def customer_detail(request: Request, customer_id: str, generate: Optional[str] = None):
    """Individual customer view with instant offer generation"""
    from engine.basic_matcher import basic_matcher
    
    customer = customers_df[customers_df["customer_id"] == customer_id]
    
    if customer.empty:
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer_dict = customer.iloc[0].to_dict()
    
    # Convert pandas Timestamp to string for template
    if 'contract_date' in customer_dict and pd.notna(customer_dict['contract_date']):
        try:
            # Handle pandas Timestamp
            if hasattr(customer_dict['contract_date'], 'strftime'):
                customer_dict['contract_date'] = customer_dict['contract_date'].strftime('%Y-%m-%d')
            else:
                customer_dict['contract_date'] = str(customer_dict['contract_date'])
        except Exception as e:
            logger.warning(f"Error converting contract_date: {e}")
            customer_dict['contract_date'] = None
    
    # Ensure all required fields exist with defaults
    customer_dict.setdefault('first_name', '')
    customer_dict.setdefault('last_name', '')
    customer_dict.setdefault('full_name', customer_dict.get('customer_id', ''))
    customer_dict.setdefault('email', '')
    customer_dict.setdefault('current_car_brand', '')
    customer_dict.setdefault('current_car_model_name', '')
    customer_dict.setdefault('current_car_year', 0)
    customer_dict.setdefault('current_car_km', 0)
    customer_dict.setdefault('has_kavak_total', False)
    customer_dict.setdefault('remaining_months', 0)
    customer_dict.setdefault('original_loan_amount', 0)
    customer_dict.setdefault('original_interest_rate', 0)
    customer_dict.setdefault('months_since_contract', 0)
    customer_dict.setdefault('car_age_at_purchase', 0)
    
    # Generate offers if requested
    offers_data = None
    if generate == "true":
        offers_data = basic_matcher.find_all_viable(customer_dict, inventory_df.to_dict('records'))
    
    context = {
        "request": request, 
        "customer": customer_dict,
        "active_page": "customers",
        "offers_data": offers_data,
        "show_offers": generate == "true",
        **get_data_context()
    }
    
    # Use enhanced template (fixed by other AI)
    return templates.TemplateResponse(
        "modern_customer_detail_enhanced.html",
        context
    )

@app.get("/customer/{customer_id}/offer/{car_id}/amortization", response_class=HTMLResponse)
async def offer_amortization(request: Request, customer_id: str, car_id: str):
    """Show detailed amortization table for a specific offer"""
    from engine.basic_matcher import basic_matcher
    import numpy as np
    
    customer = customers_df[customers_df["customer_id"] == customer_id]
    if customer.empty:
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer_dict = customer.iloc[0].to_dict()
    
    # Generate offers to find the specific one
    result = basic_matcher.find_all_viable(customer_dict, inventory_df.to_dict('records'))
    
    # Find the specific offer
    offer = None
    for tier_offers in result['offers'].values():
        for o in tier_offers:
            if str(o['car_id']) == str(car_id):
                offer = o
                break
        if offer:
            break
    
    if not offer:
        raise HTTPException(status_code=404, detail="Offer not found")
    
    # Generate amortization schedule
    principal = offer['loan_amount']
    rate = offer['interest_rate'] / 12  # Monthly rate
    payment = offer['monthly_payment']
    term = offer['term']
    
    schedule = []
    balance = principal
    total_interest = 0
    total_principal = 0
    
    for month in range(1, term + 1):
        interest_payment = balance * rate
        principal_payment = payment - interest_payment
        balance -= principal_payment
        total_interest += interest_payment
        total_principal += principal_payment
        
        schedule.append({
            'month': month,
            'payment': payment,
            'principal': principal_payment,
            'interest': interest_payment,
            'balance': max(0, balance),
            'total_paid': payment * month,
            'total_interest': total_interest
        })
    
    context = {
        "request": request,
        "customer": customer_dict,
        "offer": offer,
        "schedule": schedule,
        "total_payments": payment * term,
        "total_interest": total_interest,
        "active_page": "customers"
    }
    
    return templates.TemplateResponse(
        "amortization_table.html",
        context
    )

@app.get("/customer/{customer_id}/offers-test", response_class=HTMLResponse)
async def customer_offers_test(request: Request, customer_id: str):
    """Test page with server-side rendered offers"""
    from engine.basic_matcher import basic_matcher
    
    customer = customers_df[customers_df["customer_id"] == customer_id]
    
    if customer.empty:
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer_dict = customer.iloc[0].to_dict()
    
    # Generate offers server-side
    result = basic_matcher.find_all_viable(customer_dict, inventory_df.to_dict('records'))
    
    context = {
        "request": request, 
        "customer": customer_dict,
        "offers": result['offers'],
        "total_offers": result['total_offers'],
        "processing_time": result['processing_time'],
        "active_page": "customers",
        **get_data_context()
    }
    
    return templates.TemplateResponse(
        "modern_offers_full.html",
        context
    )

@app.get("/inventory", response_class=HTMLResponse)
async def inventory_page(request: Request):
    """Inventory management page"""
    context = {
        "request": request,
        "inventory": inventory_df.to_dict("records")[:50],  # First 50 cars
        "active_page": "inventory",
        **get_data_context()
    }
    
    return templates.TemplateResponse(
        "modern_inventory.html",
        context
    )

@app.get("/config", response_class=HTMLResponse)
async def config_page(request: Request):
    """Configuration page"""
    # Get current config from API endpoint which handles format conversion
    try:
        # Use the API endpoint that properly formats the config
        config_response = await get_config()
        config = config_response
    except:
        # Default config structure
        config = {
            "fees": {
                "service_fee_pct": 0.04,
                "cxa_pct": 0.04,
                "cac_min": 0,
                "cac_max": 0
            },
            "payment_delta_tiers": {
                "refresh": {"min": -0.05, "max": 0.05},
                "upgrade": {"min": 0.05, "max": 0.25},
                "max_upgrade": {"min": 0.25, "max": 1.0}
            },
            "business_rules": {
                "min_npv": 5000,
                "available_terms": [24, 36, 48, 60, 72],
                "kavak_total_enabled": True,
                "kavak_total_amount": 25000
            }
        }
    
    context = {
        "request": request,
        "config": config,
        "active_page": "config",
        **get_data_context()
    }
    
    return templates.TemplateResponse(
        "modern_config.html",
        context
    )


@app.get("/health", response_class=HTMLResponse)
async def health_page(request: Request):
    """Health monitoring page"""
    data_ctx = get_data_context()
    
    context = {
        "request": request,
        "active_page": "health",
        "env_vars": "Development" if os.getenv("ENV") != "production" else "Production",
        **data_ctx
    }
    
    return templates.TemplateResponse(
        "modern_health.html", 
        context
    )

# REMOVED: calculator route - api/calculator.py was deleted
# @app.get("/calculator/{customer_id}/{car_id}", response_class=HTMLResponse)
# async def offer_calculator_page(request: Request, customer_id: str, car_id: str):
#     """Detailed offer calculator for specific car"""
#     # from api.calculator import offer_calculator  # REMOVED - api/calculator.py deleted
#     # return await offer_calculator(request, customer_id, car_id, data_loader)

@app.get("/manual-simulation", response_class=HTMLResponse)
async def manual_simulation_page(request: Request, customer_id: Optional[str] = None):
    """Manual simulation page with optional customer pre-fill"""
    context = {
        "request": request,
        "active_page": "simulation"
    }
    
    # If customer_id provided, pre-fill with customer data
    if customer_id:
        customer_mask = customers_df["customer_id"] == customer_id
        if customer_mask.any():
            customer = customers_df[customer_mask].iloc[0].to_dict()
            context["prefill_customer"] = {
                "customer_id": customer_id,
                "current_payment": customer.get("current_monthly_payment", 0),
                "vehicle_equity": customer.get("vehicle_equity", 0),
                "current_car_value": customer.get("current_car_price", 0),
                "saldo_insoluto": customer.get("saldo insoluto", 0),
                "risk_profile": customer.get("risk_profile_name", "A")
            }
    
    return templates.TemplateResponse("manual_simulation.html", context)

# --- API Routes ---
@app.get("/api/customers")
async def list_customers(
    page: int = 1,
    limit: int = 20,
    search: Optional[str] = None,
    risk: Optional[str] = None,
    sort: Optional[str] = "recent"
):
    """Fast customer list with filtering and pagination"""
    start = (page - 1) * limit
    end = start + limit
    
    # Apply filters
    filtered_df = customers_df
    
    if search:
        # Enhanced search across multiple fields
        search_lower = search.lower()
        mask = (
            filtered_df["customer_id"].str.contains(search, case=False, na=False) |
            filtered_df["contract_id"].str.contains(search, case=False, na=False) |
            (filtered_df["first_name"].fillna("") + " " + filtered_df["last_name"].fillna("")).str.contains(search, case=False, na=False) |
            filtered_df["email"].str.contains(search, case=False, na=False) |
            filtered_df["current_car_model"].str.contains(search, case=False, na=False)
        )
        filtered_df = filtered_df[mask]
    
    if risk:
        if risk == "low":
            filtered_df = filtered_df[filtered_df["risk_profile_index"] <= 5]
        elif risk == "medium":
            filtered_df = filtered_df[(filtered_df["risk_profile_index"] > 5) & 
                                    (filtered_df["risk_profile_index"] <= 15)]
        elif risk == "high":
            filtered_df = filtered_df[filtered_df["risk_profile_index"] > 15]
    
    # Sort
    if sort == "payment-high":
        filtered_df = filtered_df.sort_values("current_monthly_payment", ascending=False)
    elif sort == "payment-low":
        filtered_df = filtered_df.sort_values("current_monthly_payment")
    elif sort == "equity-high":
        filtered_df = filtered_df.sort_values("vehicle_equity", ascending=False)
    
    # Paginate
    total = len(filtered_df)
    customers = filtered_df.iloc[start:end].to_dict("records")
    
    return {
        "customers": customers,
        "total": total,
        "page": page,
        "pages": (total + limit - 1) // limit
    }

@app.post("/api/generate-offers-basic")
async def generate_offers_basic(request: OfferRequest):
    """Generate ALL viable offers with standard fees - no fancy shit"""
    from engine.basic_matcher import basic_matcher
    
    start_time = time.time()
    
    # Check cache first
    cache_key = offer_cache.get_key(request.customer_id)
    cached_result = offer_cache.get(cache_key)
    if cached_result:
        logger.info(f"üöÄ Cache hit for {request.customer_id}")
        cached_result['from_cache'] = True
        return cached_result
    
    # Get customer data
    customer_mask = customers_df["customer_id"] == request.customer_id
    if not customer_mask.any():
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer = customers_df[customer_mask].iloc[0].to_dict()
    
    # Use basic matcher with parallel processing
    loop = asyncio.get_event_loop()
    inventory_records = inventory_df.to_dict("records")
    
    result = await loop.run_in_executor(
        executor,
        basic_matcher.find_all_viable,
        customer,
        inventory_records
    )
    
    # Cache the result
    offer_cache.set(cache_key, result)
    
    logger.info(f"üìä Basic matcher: {result['total_offers']} offers for {request.customer_id} in {result['processing_time']}s")
    
    return result

# REMOVED: generate_offers_with_progress - progress_matcher doesn't exist

# REMOVED: generate_offers_smart - smart_matcher doesn't exist


@app.post("/api/generate-offers-bulk")
async def generate_offers_bulk(request: BulkOfferRequest):
    """Generate offers for multiple customers in parallel"""
    start_time = time.time()
    
    # Validate all customers exist
    valid_customers = []
    for cid in request.customer_ids[:50]:  # Max 50 at once
        if cid in customers_df["customer_id"].values:
            valid_customers.append(cid)
    
    if not valid_customers:
        raise HTTPException(status_code=400, detail="No valid customers found")
    
    # Process in parallel
    tasks = []
    for customer_id in valid_customers:
        req = OfferRequest(
            customer_id=customer_id,
            max_offers=request.max_offers_per_customer
        )
        tasks.append(generate_offers_smart(req))
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Format results
    successful = []
    failed = []
    
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            failed.append({
                "customer_id": valid_customers[i],
                "error": str(result)
            })
        else:
            successful.append({
                "customer_id": valid_customers[i],
                "offers_count": sum(len(offers) for offers in result["offers"].values()),
                "best_npv": max(
                    (offer.get("npv", 0) for tier_offers in result["offers"].values() 
                     for offer in tier_offers),
                    default=0
                )
            })
    
    return {
        "processed": len(valid_customers),
        "successful": len(successful),
        "failed": len(failed),
        "results": successful,
        "errors": failed,
        "processing_time": round(time.time() - start_time, 2)
    }

@app.post("/api/search")
async def search_everything(request: SearchRequest):
    """Universal search across customers, inventory, and offers"""
    query = request.query.lower()
    results = {
        "customers": [],
        "inventory": [],
        "query": request.query,
        "total": 0
    }
    
    # Search customers
    if len(customers_df) > 0:
        customer_matches = customers_df[
            customers_df["customer_id"].str.contains(query, case=False, na=False) |
            customers_df["contract_id"].str.contains(query, case=False, na=False)
        ].head(request.limit)
        
        results["customers"] = customer_matches.to_dict("records")
    
    # Search inventory
    if len(inventory_df) > 0:
        inventory_matches = inventory_df[
            inventory_df["model"].str.contains(query, case=False, na=False)
        ].head(request.limit)
        
        results["inventory"] = inventory_matches.to_dict("records")
    
    results["total"] = len(results["customers"]) + len(results["inventory"])
    
    return results

@app.get("/api/health")
async def health_check():
    """Health check API endpoint"""
    data_ctx = get_data_context()
    
    return JSONResponse({
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "version": "2.0.0",
        "engine": "simple_v2",
        "mode": data_ctx["data_source"],
        "data": {
            "customers": len(customers_df),
            "inventory": len(inventory_df),
            "cache_size": len(offer_cache),
            "sources": {
                "customers": data_ctx["customer_source"],
                "inventory": data_ctx["inventory_source"]
            }
        },
        "environment": {
            "DISABLE_EXTERNAL_CALLS": os.getenv("DISABLE_EXTERNAL_CALLS", "false"),
            "REDSHIFT_HOST": "configured" if os.getenv("REDSHIFT_HOST") else "missing"
        }
    })

@app.get("/api/config")
async def get_config():
    """Get current engine configuration"""
    from config.config import DEFAULT_FEES, PAYMENT_DELTA_TIERS, TERM_SEARCH_ORDER
    
    try:
        # Try to load from file
        with open("config/engine_config.json", "r") as f:
            stored_config = json.load(f)
            
            # Check if it's the old format (has service_fee instead of fees object)
            if "service_fee" in stored_config:
                # Convert old format to new format
                return {
                    "fees": {
                        "service_fee_pct": stored_config.get('service_fee', 5) / 100,  # Convert to decimal
                        "cxa_pct": stored_config.get('cxa_fee', 4) / 100,  # Convert to decimal
                        "cac_min": 0,
                        "cac_max": 5000
                    },
                    "payment_delta_tiers": {
                        "refresh": {
                            "min": PAYMENT_DELTA_TIERS['Refresh'][0],
                            "max": PAYMENT_DELTA_TIERS['Refresh'][1]
                        },
                        "upgrade": {
                            "min": PAYMENT_DELTA_TIERS['Upgrade'][0],
                            "max": PAYMENT_DELTA_TIERS['Upgrade'][1]
                        },
                        "max_upgrade": {
                            "min": PAYMENT_DELTA_TIERS['Max Upgrade'][0],
                            "max": PAYMENT_DELTA_TIERS['Max Upgrade'][1]
                        }
                    },
                    "business_rules": {
                        "min_npv": stored_config.get('min_npv_threshold', 5000),
                        "available_terms": TERM_SEARCH_ORDER,
                        "kavak_total_enabled": True,
                        "kavak_total_amount": DEFAULT_FEES['kavak_total_amount']
                    }
                }
            else:
                # It's already in the new format
                return stored_config
                
    except FileNotFoundError:
        pass
    except Exception as e:
        logger.error(f"Failed to load config: {e}")
    
    # Return default config
    return {
        "fees": {
            "service_fee_pct": DEFAULT_FEES['service_fee_pct'],
            "cxa_pct": DEFAULT_FEES['cxa_pct'],
            "cac_min": 0,
            "cac_max": 5000
        },
        "payment_delta_tiers": {
            "refresh": {
                "min": PAYMENT_DELTA_TIERS['Refresh'][0],
                "max": PAYMENT_DELTA_TIERS['Refresh'][1]
            },
            "upgrade": {
                "min": PAYMENT_DELTA_TIERS['Upgrade'][0],
                "max": PAYMENT_DELTA_TIERS['Upgrade'][1]
            },
            "max_upgrade": {
                "min": PAYMENT_DELTA_TIERS['Max Upgrade'][0],
                "max": PAYMENT_DELTA_TIERS['Max Upgrade'][1]
            }
        },
        "business_rules": {
            "min_npv": 5000,
            "available_terms": TERM_SEARCH_ORDER,
            "kavak_total_enabled": True,
            "kavak_total_amount": DEFAULT_FEES['kavak_total_amount']
        }
    }

@app.post("/api/save-config")
async def save_config(config: Dict):
    """Save engine configuration"""
    try:
        # Validate and transform the config to match engine format
        engine_config = {
            "fees": config.get("fees", {}),
            "payment_delta_tiers": config.get("payment_delta_tiers", {}),
            "business_rules": config.get("business_rules", {}),
            "timestamp": datetime.now().isoformat()
        }
        
        with open("config/engine_config.json", "w") as f:
            json.dump(engine_config, f, indent=2)
            
        # Update the actual config values in memory
        from config import business_rules as core_config
        
        # Update fees
        if "fees" in config:
            core_config.DEFAULT_FEES['service_fee_pct'] = config['fees'].get('service_fee_pct', 0.04)
            core_config.DEFAULT_FEES['cxa_pct'] = config['fees'].get('cxa_pct', 0.04)
            core_config.MAX_CAC_BONUS = config['fees'].get('cac_max', 5000)
            
        # Update payment delta tiers
        if "payment_delta_tiers" in config:
            tiers = config['payment_delta_tiers']
            core_config.PAYMENT_DELTA_TIERS['Refresh'] = (
                tiers['refresh']['min'], 
                tiers['refresh']['max']
            )
            core_config.PAYMENT_DELTA_TIERS['Upgrade'] = (
                tiers['upgrade']['min'], 
                tiers['upgrade']['max']
            )
            core_config.PAYMENT_DELTA_TIERS['Max Upgrade'] = (
                tiers['max_upgrade']['min'], 
                tiers['max_upgrade']['max']
            )
            
        # Update business rules
        if "business_rules" in config:
            rules = config['business_rules']
            if 'available_terms' in rules:
                core_config.TERM_SEARCH_ORDER = rules['available_terms']
            if 'kavak_total_amount' in rules:
                core_config.DEFAULT_FEES['kavak_total_amount'] = rules['kavak_total_amount']
        
        return {"status": "success", "message": "Configuration saved and applied"}
    except Exception as e:
        logger.error(f"Failed to save config: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/metrics")
async def get_metrics():
    """Real-time metrics for dashboard"""
    # In production, these would come from a metrics service
    return {
        "offers_generated_today": 342,
        "avg_processing_time": 1.2,
        "conversion_rate": 68,
        "total_npv_today": 2_567_000,
        "top_segments": [
            {"segment": "Low_Premium_High", "count": 120, "avg_npv": 8500},
            {"segment": "Low_Standard_High", "count": 89, "avg_npv": 6200},
            {"segment": "Medium_Standard_High", "count": 67, "avg_npv": 5100}
        ],
        "hourly_trend": [
            {"hour": "9AM", "offers": 23, "conversions": 15},
            {"hour": "10AM", "offers": 45, "conversions": 31},
            {"hour": "11AM", "offers": 67, "conversions": 48},
            {"hour": "12PM", "offers": 52, "conversions": 35},
            {"hour": "1PM", "offers": 38, "conversions": 26},
            {"hour": "2PM", "offers": 71, "conversions": 49},
            {"hour": "3PM", "offers": 46, "conversions": 32}
        ]
    }

# --- New API endpoint for schedule JSON ---
# Allows front-end to retrieve server-calculated amortization so that JS never
# re-computes the numbers (single source of truth).

@app.post("/api/amortization")
async def amortization_api(offer: Dict = Body(...)):
    """Return amortization schedule for a given offer.

    The *offer* param is exactly one of the objects returned by the matcher,
    containing at minimum:
      loan_amount, term, interest_rate, service_fee_amount, kavak_total_amount,
      insurance_amount, gps_monthly_fee.
    """
    from engine.calculator import generate_amortization_table
    schedule = generate_amortization_table(offer)

    # Fix field names to match frontend expectations
    for row in schedule:
        # Frontend expects 'balance' field
        row['balance'] = row.get('ending_balance', 0)

    return {
        "schedule": schedule,
        "table": schedule,  # Frontend expects 'table' field
        "payment_total": schedule[0]["payment"] if schedule else 0,
        "principal_month1": schedule[0]["principal"] if schedule else 0,
        "interest_month1": schedule[0]["interest"] if schedule else 0,
        "gps_fee": schedule[0]["cargos"] if schedule else 0,
        "cargos": schedule[0]["cargos"] if schedule else 0,
    }

# Add the endpoint with the name frontend expects
@app.post("/api/amortization-table")
async def amortization_table_api(offer: Dict = Body(...)):
    """Alias for amortization API - frontend calls this endpoint"""
    return await amortization_api(offer)

# --- Error Handlers ---
@app.exception_handler(404)
async def not_found_handler(request: Request, exc: HTTPException):
    if request.url.path.startswith("/api/"):
        return JSONResponse(
            status_code=404,
            content={"detail": "Resource not found"}
        )
    return templates.TemplateResponse(
        "404.html",
        {"request": request},
        status_code=404
    )

@app.exception_handler(500)
async def server_error_handler(request: Request, exc: Exception):
    logger.error(f"Server error: {exc}")
    if request.url.path.startswith("/api/"):
        return JSONResponse(
            status_code=500,
            content={"detail": "Internal server error"}
        )
    return templates.TemplateResponse(
        "500.html",
        {"request": request},
        status_code=500
    )

# REMOVED: manual_simulation_api - calculate_offer_details doesn't exist
@app.post("/api/manual-simulation")
async def manual_simulation_api(request: Dict):
    """Calculate offers for manual simulation"""
    # TODO: Re-implement using basic_matcher
    raise HTTPException(status_code=501, detail="Manual simulation temporarily disabled - needs reimplementation")

@app.post("/api/generate-offers-custom")
async def generate_offers_custom(request: Dict):
    """Generate offers with custom configuration per customer"""
    from engine.basic_matcher import basic_matcher
    
    start_time = time.time()
    
    # Use custom fees from request
    custom_fees = {
        'service_fee_pct': request.get('service_fee_pct', 0.04),
        'cxa_pct': request.get('cxa_pct', 0.04),
        'cac_bonus': request.get('cac_bonus', 0),
        'insurance_amount': request.get('insurance_amount', 10999),
        'interest_rate': request.get('interest_rate')  # If provided, will override risk profile rate
    }
    
    # Check cache first with custom fees
    cache_key = offer_cache.get_key(request['customer_id'], custom_fees)
    cached_result = offer_cache.get(cache_key)
    if cached_result:
        logger.info(f"üöÄ Cache hit for {request['customer_id']} with custom fees")
        cached_result['from_cache'] = True
        cached_result['mode'] = 'custom_config'
        return cached_result
    
    # Get customer data
    customer_mask = customers_df["customer_id"] == request['customer_id']
    if not customer_mask.any():
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer = customers_df[customer_mask].iloc[0].to_dict()
    
    # Use basic matcher with custom fees and parallel processing
    loop = asyncio.get_event_loop()
    inventory_records = inventory_df.to_dict("records")
    
    # Pass custom fees to the matcher
    result = await loop.run_in_executor(
        executor,
        basic_matcher.find_all_viable,
        customer,
        inventory_records,
        custom_fees
    )
    result['mode'] = 'custom_config'
    
    # Cache the result
    offer_cache.set(cache_key, result)
    
    logger.info(f"üìä Custom matcher: {result['total_offers']} offers for {request['customer_id']} in {result['processing_time']}s")
    
    return result

@app.post("/api/smart-search")
async def smart_search_api(request: Dict):
    """Smart search API - finds optimal offers with minimum subsidy"""
    from engine.smart_search import (
        smart_search_engine, ConsiderationFilters, SubsidyConfig
    )
    
    start_time = time.time()
    
    # Get customer data
    customer_mask = customers_df["customer_id"] == request['customer_id']
    if not customer_mask.any():
        raise HTTPException(status_code=404, detail="Customer not found")
    
    customer = customers_df[customer_mask].iloc[0].to_dict()
    
    # Parse filters
    filters = ConsiderationFilters(
        price_min=request.get('price_min'),
        price_max=request.get('price_max'),
        brands=request.get('brands'),
        year_min=request.get('year_min'),
        year_max=request.get('year_max'),
        km_max=request.get('km_max'),
        has_promotion=request.get('has_promotion'),
        regions=request.get('regions'),
        vehicle_classes=request.get('vehicle_classes'),
        colors=request.get('colors')
    )
    
    # Parse subsidy config
    config = SubsidyConfig(
        service_fee_max=request.get('service_fee_max', 0.05),
        service_fee_min=request.get('service_fee_min', 0.02),
        service_fee_step=request.get('service_fee_step', 0.005),
        cac_min=request.get('cac_min', 0),
        cac_max=request.get('cac_max', 10000),
        cac_step=request.get('cac_step', 500),
        cxa_max=request.get('cxa_max', 0.04),
        cxa_min=request.get('cxa_min', 0.01),
        cxa_step=request.get('cxa_step', 0.005),
        kavak_total_enabled=request.get('kavak_total_enabled', True),
        kavak_total_amount=request.get('kavak_total_amount', 25000)
    )
    
    # Run smart search
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(
        executor,
        smart_search_engine.search_smart_offers,
        customer,
        inventory_df,
        filters,
        config,
        request.get('max_results', 10)
    )
    
    result['api_processing_time'] = round(time.time() - start_time, 2)
    
    logger.info(f"üéØ Smart search completed: {result['statistics']['viable_found']} viable offers "
                f"from {result['statistics']['total_candidates']} candidates in {result['api_processing_time']}s")
    
    return result

@app.get("/api/inventory/filters")
async def get_inventory_filters():
    """Get available filter options from current inventory"""
    # Extract unique values for filter dropdowns
    brands = inventory_df['model'].str.split().str[0].unique().tolist()
    regions = inventory_df['region'].unique().tolist()
    colors = inventory_df['color'].unique().tolist()
    
    # Extract years
    years = inventory_df['model'].str.extract(r'(\d{4})')[0]
    years = pd.to_numeric(years, errors='coerce').dropna().unique()
    years = sorted(years.tolist())
    
    # Price range
    price_min = int(inventory_df['sales_price'].min())
    price_max = int(inventory_df['sales_price'].max())
    
    # KM range
    km_max = int(inventory_df['kilometers'].max())
    
    return {
        "brands": sorted(brands),
        "regions": sorted(regions),
        "colors": sorted(colors),
        "years": years,
        "price_range": {
            "min": price_min,
            "max": price_max,
            "step": 10000
        },
        "km_range": {
            "min": 0,
            "max": km_max,
            "step": 5000
        },
        "vehicle_classes": ["SUV", "Sedan", "Hatchback", "Truck", "Other"]
    }

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )